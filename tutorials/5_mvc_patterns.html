<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Tutorial 5: MVC Patterns</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/devicons.min.css" rel="stylesheet">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="shortcut icon" href="../favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
   


        <!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <img style="display: block; float: left; padding: 10px" src="/img/griffon-icon-32x32.png" />
          <a class="navbar-brand" href="../index.html">Griffon</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../whygriffon.html">Why Griffon</a></li>
            <li><a href="../news/">News</a></li>
            <li><a href="../documentation.html">Documentation</a></li>
            <li><a href="../tutorials/">Tutorials</a></li>
            <li><a href="../plugins.html">Plugins</a></li>
            <li><a href="../development.html">Development</a></li>
            <li><a href="../about.html">About</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
    
    <div class="page-header">
        <h1>Tutorial 5: MVC Patterns</h1>
    </div>

    <p><div class="sect1">
<h2 id="_tutorial_5_toc">Agenda</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This tutorial describes how to leverage different MVC patterns, such as</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Model - View - Controller</p>
</li>
<li>
<p>Model - View - Presenter</p>
</li>
<li>
<p>Model - View - ViewModel</p>
</li>
<li>
<p>PresentationModel - View - Controller</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The goal is to build the same application using different patterns.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#_tutorial_5_1">Definitions</a></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><a href="#_tutorial_5_1_1">Model-View-Controller</a></p>
</li>
<li>
<p><a href="#_tutorial_5_1_2">Model-View-Presenter</a></p>
</li>
<li>
<p><a href="#_tutorial_5_1_3">Model-View-ViewModel</a></p>
</li>
<li>
<p><a href="#_tutorial_5_1_4">PresentationModel-View-Controller</a></p>
</li>
</ol>
</div>
</li>
<li>
<p><a href="#_tutorial_5_2">Implementations</a></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><a href="#_tutorial_5_2_1">Common Files</a></p>
</li>
<li>
<p><a href="#_tutorial_5_2_2">Model-View-Controller</a></p>
</li>
<li>
<p><a href="#_tutorial_5_2_3">Model-View-Presenter</a></p>
</li>
<li>
<p><a href="#_tutorial_5_2_4">Model-View-ViewModel</a></p>
</li>
<li>
<p><a href="#_tutorial_5_2_5">PresentationModel-View-Controller</a></p>
</li>
</ol>
</div>
</li>
<li>
<p><a href="#_tutorial_5_3">Conclusions</a></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_5_1">1. Definitions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_tutorial_5_1_1">1.1. MVC: Model-View-Controller</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">https://en.wikipedia.org/wiki/Model-view-controller</a></p>
</div>
<div class="paragraph">
<p>Perhaps the most well known pattern, also the one that many will get wrong and implement in an even worse way. The MVC
pattern arose as a solution to keep 3 concerns separate from each other: visuals (<strong>View</strong>), data (<strong>Model</strong>), and logic
(<strong>Controller</strong>). The pattern is easy to understand but hard to implement given that its generic description: a triangle
where all parts can communicate with each other. Problem is, the links between some parts may be passive, for example
some claim the <strong>View</strong> may only read the <strong>Model</strong> but do not update it directly, where as others claim data flows equally
both ways.</p>
</div>
<div class="paragraph">
<p>The following diagram presents one of the many ways in which this pattern may be implemented; the dotted lines represent
passive links.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/img/patterns/mvc.png" alt="mvc">
</div>
<div class="title">Figure 1. MVC</div>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_tutorial_5_1_2">1.2. MVP: Model-View-Presenter</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">https://en.wikipedia.org/wiki/Model-view-presenter</a></p>
</div>
<div class="paragraph">
<p>This pattern emerged as a counterpoint for MVC, trying to solve the triangle problem. In this pattern the <strong>View</strong> is passive
and only reacts to data sent by the <strong>Presenter</strong>, which came from the <strong>Model</strong>. The <strong>View</strong> can route user events to the
<strong>Presenter</strong> but does not know the <strong>Model</strong>. The <strong>Model</strong> in turn receives updates from the <strong>Presenter</strong> and notifies it of
any state changes, resulting in an isolated <strong>Model</strong>. Only the <strong>Presenter</strong> knows the other two members of the pattern.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/img/patterns/mvp.png" alt="mvp">
</div>
<div class="title">Figure 2. MVP</div>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_tutorial_5_1_3">1.3. MVVM: Model-View-ViewModel</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">https://en.wikipedia.org/wiki/Model-view-viewmodel</a></p>
</div>
<div class="paragraph">
<p>The MVVM pattern is a weird variation if you ask me, as it puts the logic between the <strong>View</strong> and the <strong>ViewModel</strong>. The
<strong>ViewModel</strong> is responsible for abstracting all <strong>View</strong> input/outputs while providing behavior at the same time. This
simplifies (in theory) testing of an application built with this pattern as the <strong>ViewModel</strong> has the lion&#8217;s share of
data and behavior, and it&#8217;s separated from the <strong>View</strong>. Perhaps the most interesting feature coming from this pattern is
the availability of a <strong>Binder</strong>, used to synchronize data between <strong>View</strong> and <strong>ViewModel</strong>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/img/patterns/mvvm.png" alt="mvvm">
</div>
<div class="title">Figure 3. MVVM</div>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_tutorial_5_1_4">1.4. PMVC: PresentationModel-View-Controller</h3>
<div class="paragraph">
<p>The PMVC pattern is the ultimate variation of MVC, where we&#8217;re back to the triangle but this time we&#8217;ve got clear links
between members. The <strong>PresentationModel</strong> is responsible for holding information used to display the application&#8217;s data
and hints to how said data should be visualized, such as colors, fonts, etc. Similarly to MVVM, the <strong>View</strong> benefits from
a <strong>Binder</strong> that can tie data from the <strong>PresentationModel</strong> to the <strong>View</strong>'s UI elements. The <strong>Controller</strong> is now content
to manipulate the <strong>PresentationModel</strong> directly, completely oblivious about a specific <strong>View</strong>. This leads to a much more
testable outcome, as the <strong>PresentationModel</strong> and <strong>Controller</strong> are completely separate from the <strong>View</strong>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/img/patterns/pmvc.png" alt="pmvc">
</div>
<div class="title">Figure 4. PMVC</div>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_5_2">2. Implementations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s time to get down with business. The following sections describe the implementation of each pattern using the
<a href="https://griffon-framework.org/">Griffon</a> framework. All applications use JavaFX as the toolkit of choice.</p>
</div>
<div class="sect2">
<h3 id="_tutorial_5_2_1">2.1. Common Files</h3>
<div class="paragraph">
<p>Regardless of the pattern all UIs rely on FXML to describe the <strong>View</strong> in a declarative approach as much as possible.
The following FXML file is thus shared by all applications</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/resources/org/example/sample.fxml</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
--&gt;
&lt;?import javafx.scene.control.Button?&gt;
&lt;?import javafx.scene.control.Label?&gt;
&lt;?import javafx.scene.control.TextField?&gt;
&lt;?import javafx.scene.layout.AnchorPane?&gt;
&lt;AnchorPane id="AnchorPane" maxHeight="-Infinity" maxWidth="-Infinity"
            minHeight="-Infinity" minWidth="-Infinity"
            prefHeight="80.0" prefWidth="384.0"
            xmlns:fx="http://javafx.com/fxml"
            fx:controller="org.example.SampleView"&gt;
    &lt;Label layoutX="14.0" layoutY="14.0" text="Please enter your name:"/&gt;
    &lt;TextField fx:id="input" layoutX="172.0" layoutY="11.0"
               prefWidth="200.0"/&gt;
    &lt;Button layoutX="172.0" layoutY="45.0"
            mnemonicParsing="false"
            prefWidth="200.0"
            text="Say hello!"
            styleClass="btn, btn-primary"
            fx:id="sayHelloActionTarget"/&gt;
    &lt;Label layoutX="14.0" layoutY="80.0" prefWidth="360.0" fx:id="output"/&gt;
&lt;/AnchorPane&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Input data is transformed by a simple service class, also shared by all applications</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/services/org/example/SampleService.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonService;
import griffon.core.i18n.MessageSource;
import griffon.metadata.ArtifactProviderFor;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonService;

import static griffon.util.GriffonNameUtils.isBlank;
import static java.util.Arrays.asList;

@ArtifactProviderFor(GriffonService.class)
public class SampleService extends AbstractGriffonService {
    public String sayHello(String input) {
        MessageSource messageSource = getApplication().getMessageSource();
        if (isBlank(input)) {
            return messageSource.getMessage("greeting.default");
        } else {
            return messageSource.getMessage("greeting.parameterized", asList(input));
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally the i18n messages required by the service</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/i18n/messages.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">#

name.label = Please enter your name
greeting.default = Howdy stranger!
greeting.parameterized = Hello {0}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alright, we can now have a look at each specific pattern.</p>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_tutorial_5_2_2">2.2. MVC</h3>
<div class="paragraph">
<p>Let&#8217;s begin with the <strong>View</strong>, as this is the pattern member the user will interact. The <strong>View</strong> in this case is pretty
straight forward, as it only needs to load the FXML file that contains the descriptive UI. However it also exposes two
UI elements (<em>input</em> and <em>output</em>) in order for the <strong>Controller</strong> and <strong>Model</strong> to read data and supply updates.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/views/org/example/SampleView.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonView;
import griffon.inject.MVCMember;
import griffon.metadata.ArtifactProviderFor;
import javafx.fxml.FXML;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import org.codehaus.griffon.runtime.javafx.artifact.AbstractJavaFXGriffonView;

import javax.annotation.Nonnull;
import java.util.Collections;

@ArtifactProviderFor(GriffonView.class)
public class SampleView extends AbstractJavaFXGriffonView {
    private SampleController controller;

    @FXML private TextField input;
    @FXML private Label output;

    @MVCMember
    public void setController(@Nonnull SampleController controller) {
        this.controller = controller;
    }

    @Override
    public void initUI() {
        Stage stage = (Stage) getApplication()
            .createApplicationContainer(Collections.&lt;String, Object&gt;emptyMap());
        stage.setTitle(getApplication().getConfiguration().getAsString("application.title"));
        stage.setWidth(400);
        stage.setHeight(120);
        stage.setScene(init());
        getApplication().getWindowManager().attach("mainWindow", stage);
    }

    // build the UI
    private Scene init() {
        Scene scene = new Scene(new Group());
        scene.setFill(Color.WHITE);
        scene.getStylesheets().add("bootstrapfx.css");

        Node node = loadFromFXML();
        ((Group) scene.getRoot()).getChildren().addAll(node);
        connectActions(node, controller);                                      <i class="conum" data-value="1"></i><b>(1)</b>

        return scene;
    }

    @Nonnull
    public TextField getInput() {                                              <i class="conum" data-value="2"></i><b>(2)</b>
        return input;
    }

    @Nonnull
    public Label getOutput() {                                                 <i class="conum" data-value="2"></i><b>(2)</b>
        return output;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Connects user events to <strong>Controller</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Exposes UI elements</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next comes the <strong>Model</strong>, responsible for holding the data required by the <strong>View</strong>. Notice that this particular implementation
notifies the <strong>View</strong> using proper threading concerns, that is, data is pushed to the <strong>View</strong> only inside the UI thread.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/models/org/example/SampleModel.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonModel;
import griffon.inject.MVCMember;
import griffon.metadata.ArtifactProviderFor;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonModel;

import javax.annotation.Nonnull;
import java.util.Map;

@ArtifactProviderFor(GriffonModel.class)
public class SampleModel extends AbstractGriffonModel {
    private StringProperty output;
    private SampleView view;

    @Nonnull
    public final StringProperty outputProperty() {
        if (output == null) {
            output = new SimpleStringProperty(this, "output");
        }
        return output;
    }

    public void setOutput(String output) {
        outputProperty().set(output);
    }

    public String getOutput() {
        return output == null ? null : outputProperty().get();
    }

    @MVCMember
    public void setView(@Nonnull SampleView view) {
        this.view = view;
    }

    @Override
    public void mvcGroupInit(@Nonnull Map&lt;String, Object&gt; args) {
        outputProperty().addListener((observable, oldValue, newValue) -&gt; {
            runInsideUIAsync(() -&gt; view.getOutput().setText(newValue));        <i class="conum" data-value="1"></i><b>(1)</b>
        });
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Notifies <strong>View</strong></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally we get to the <strong>Controller</strong>, where we can see how it reacts to user events (the click on a button), reads data from
the <strong>View</strong>, transforms said data, then sends it to the <strong>Model</strong>. As we saw earlier, the <strong>Model</strong> closes the circuit by updating
the <strong>View</strong>. You may be wondering, how is the connection established between <strong>Controller</strong> and <strong>View</strong>? If you look back at
the FXML file you&#8217;ll notice that the button has an id equal to <code>sayHelloActionTarget</code>.  That name is really close to one
of the <strong>Controller</strong>'s public methods. Also, in the <strong>View</strong> there&#8217;s a call to <code>connectActions</code> that takes a <code>controller</code>
argument. Here Griffon expects a naming convention (the name of the action method plus the name of the button&#8217;s id), which
if followed correctly, will make the a connection between <strong>Controller</strong> and <strong>View</strong>.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/controllers/org/example/SampleController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonController;
import griffon.inject.MVCMember;
import griffon.metadata.ArtifactProviderFor;
import griffon.transform.Threading;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonController;

import javax.annotation.Nonnull;
import javax.inject.Inject;

@ArtifactProviderFor(GriffonController.class)
public class SampleController extends AbstractGriffonController {
    private SampleModel model;
    private SampleView view;

    @Inject
    private SampleService sampleService;

    @MVCMember
    public void setModel(@Nonnull SampleModel model) {
        this.model = model;
    }

    @MVCMember
    public void setView(@Nonnull SampleView view) {
        this.view = view;
    }

    @Threading(Threading.Policy.INSIDE_UITHREAD_ASYNC)
    public void sayHello() {
        String input = view.getInput().getText();                              <i class="conum" data-value="1"></i><b>(1)</b>
        String output = sampleService.sayHello(input);                         <i class="conum" data-value="2"></i><b>(2)</b>
        model.setOutput(output);                                               <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Read input</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Transform data</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Set as output</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Given the trivial nature of this application you may be wondering if it&#8217;s worthwhile having a <strong>Model</strong> at all. And you may
be right, however the <strong>Model</strong> is shown here to compare the different implementations that follow.</p>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_tutorial_5_2_3">2.3. MVP</h3>
<div class="paragraph">
<p>The <strong>View</strong> in this pattern is a passive one. Curiously enough we can implement it in the same way as we did with the MVC
pattern. The resulting <strong>View</strong> turns out to be exactly the same as before.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/views/org/example/SampleView.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonView;
import griffon.inject.MVCMember;
import griffon.metadata.ArtifactProviderFor;
import javafx.fxml.FXML;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import org.codehaus.griffon.runtime.javafx.artifact.AbstractJavaFXGriffonView;

import javax.annotation.Nonnull;
import java.util.Collections;

@ArtifactProviderFor(GriffonView.class)
public class SampleView extends AbstractJavaFXGriffonView {
    private SamplePresenter presenter;

    @FXML private TextField input;
    @FXML private Label output;

    @MVCMember
    public void setPresenter(@Nonnull SamplePresenter presenter) {
        this.presenter = presenter;
    }

    @Override
    public void initUI() {
        Stage stage = (Stage) getApplication()
            .createApplicationContainer(Collections.&lt;String, Object&gt;emptyMap());
        stage.setTitle(getApplication().getConfiguration().getAsString("application.title"));
        stage.setWidth(400);
        stage.setHeight(120);
        stage.setScene(init());
        getApplication().getWindowManager().attach("mainWindow", stage);
    }

    // build the UI
    private Scene init() {
        Scene scene = new Scene(new Group());
        scene.setFill(Color.WHITE);
        scene.getStylesheets().add("bootstrapfx.css");

        Node node = loadFromFXML();
        ((Group) scene.getRoot()).getChildren().addAll(node);
        connectActions(node, presenter);                                       <i class="conum" data-value="1"></i><b>(1)</b>

        return scene;
    }

    @Nonnull
    public TextField getInput() {                                              <i class="conum" data-value="2"></i><b>(2)</b>
        return input;
    }

    @Nonnull
    public Label getOutput() {                                                 <i class="conum" data-value="2"></i><b>(2)</b>
        return output;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Connects user events to <strong>Presenter</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Exposes UI elements</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We&#8217;ll see some changes in the remaining pattern members. The <strong>Model</strong> is again just a data holder, with just a single
property that takes care of the output to be displayed. There&#8217;s nothing more to it given that this class uses JavaFX
properties, and as such we&#8217;ll use event listeners to let the <strong>Model</strong> notify the <strong>Presenter</strong> when a state change occurs.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/models/org/example/SampleModel.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonModel;
import griffon.metadata.ArtifactProviderFor;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonModel;

import javax.annotation.Nonnull;

@ArtifactProviderFor(GriffonModel.class)
public class SampleModel extends AbstractGriffonModel {
    private StringProperty output;

    @Nonnull
    public final StringProperty outputProperty() {
        if (output == null) {
            output = new SimpleStringProperty(this, "output");
        }
        return output;
    }

    public void setOutput(String output) {
        outputProperty().set(output);
    }

    public String getOutput() {
        return output == null ? null : outputProperty().get();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we get to the <strong>Presenter</strong>. Griffon allows MVC members to have any name you deem fit, however their
responsibilities must be clearly stated, using the <code>@ArtifactProviderFor</code> annotation and a given MVC interface. At the
moment of writing there&#8217;s no <code>GriffonPresenter</code> interface, and it&#8217;s likely there&#8217;ll never be, as this example shows
the current types are more than enough to provide the required behavior</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/controllers/org/example/SamplePresenter.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonController;
import griffon.inject.MVCMember;
import griffon.metadata.ArtifactProviderFor;
import griffon.transform.Threading;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonController;

import javax.annotation.Nonnull;
import javax.inject.Inject;
import java.util.Map;

@ArtifactProviderFor(GriffonController.class)
public class SamplePresenter extends AbstractGriffonController {
    private SampleModel model;
    private SampleView view;

    @Inject
    private SampleService sampleService;

    @MVCMember
    public void setModel(@Nonnull SampleModel model) {
        this.model = model;
    }

    @MVCMember
    public void setView(@Nonnull SampleView view) {
        this.view = view;
    }

    @Override
    public void mvcGroupInit(@Nonnull Map&lt;String, Object&gt; args) {
        model.outputProperty().addListener((observable, oldValue, newValue) -&gt; {
            runInsideUIAsync(() -&gt; view.getOutput().setText(newValue));        <i class="conum" data-value="4"></i><b>(4)</b>
        });
    }

    @Threading(Threading.Policy.INSIDE_UITHREAD_ASYNC)
    public void sayHello() {
        String input = view.getInput().getText();                              <i class="conum" data-value="1"></i><b>(1)</b>
        String output = sampleService.sayHello(input);                         <i class="conum" data-value="2"></i><b>(2)</b>
        model.setOutput(output);                                               <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Read input</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Transform data</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Set as output</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Notifies <strong>View</strong></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Last but not least, we have to cover the application&#8217;s configuration in terms of MVC definitions, given that we&#8217;re using
<code>presenter</code> instead of <code>controller</code>.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/conf/Config.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
import griffon.util.AbstractMapResourceBundle;

import javax.annotation.Nonnull;
import java.util.Map;

import static griffon.util.CollectionUtils.map;
import static java.util.Arrays.asList;

public class Config extends AbstractMapResourceBundle {
    @Override
    protected void initialize(@Nonnull Map&lt;String, Object&gt; entries) {
        map(entries)
            .e("application", map()
                .e("title", "sample")
                .e("startupGroups", asList("sample"))
                .e("autoShutdown", true)
            )
            .e("mvcGroups", map()
                .e("sample", map()
                    .e("model", "org.example.SampleModel")
                    .e("view", "org.example.SampleView")
                    .e("presenter", "org.example.SamplePresenter")
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The configuration is quite flexible to allow us a simple rename.</p>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_tutorial_5_2_4">2.4. MVVM</h3>
<div class="paragraph">
<p>On to the third pattern, MVVM. The <strong>View</strong> is again a passive one. A <strong>Binder</strong> makes it easy to keep data in sync between
the <strong>View</strong> and the <strong>ViewModel</strong>. I opted to make use of the <strong>Binder</strong> in the <strong>View</strong>, rendering it almost exactly the same
as in the previous two patterns.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/views/org/example/SampleView.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonView;
import griffon.inject.MVCMember;
import griffon.metadata.ArtifactProviderFor;
import javafx.fxml.FXML;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import org.codehaus.griffon.runtime.javafx.artifact.AbstractJavaFXGriffonView;

import javax.annotation.Nonnull;
import java.util.Collections;

@ArtifactProviderFor(GriffonView.class)
public class SampleView extends AbstractJavaFXGriffonView {
    private SampleViewModel viewModel;

    @FXML private TextField input;
    @FXML private Label output;

    @MVCMember
    public void setViewModel(@Nonnull SampleViewModel viewModel) {
        this.viewModel = viewModel;
    }

    @Override
    public void initUI() {
        Stage stage = (Stage) getApplication()
            .createApplicationContainer(Collections.&lt;String, Object&gt;emptyMap());
        stage.setTitle(getApplication().getConfiguration().getAsString("application.title"));
        stage.setWidth(400);
        stage.setHeight(120);
        stage.setScene(init());
        getApplication().getWindowManager().attach("mainWindow", stage);
    }

    // build the UI
    private Scene init() {
        Scene scene = new Scene(new Group());
        scene.setFill(Color.WHITE);
        scene.getStylesheets().add("bootstrapfx.css");

        Node node = loadFromFXML();
        ((Group) scene.getRoot()).getChildren().addAll(node);
        connectActions(node, viewModel);                                       <i class="conum" data-value="1"></i><b>(1)</b>
        input.textProperty().bindBidirectional(viewModel.inputProperty());     <i class="conum" data-value="2"></i><b>(2)</b>
        output.textProperty().bindBidirectional(viewModel.outputProperty());   <i class="conum" data-value="2"></i><b>(2)</b>

        return scene;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Connects user events to <strong>ViewModel</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Binds <strong>ViewModel</strong> and <strong>View</strong></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now, the <strong>ViewModel</strong> contains data and behavior, essentially, a combination of <strong>Model</strong> and <strong>Controller</strong>/<strong>Presenter</strong> as
seen in previous patterns</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/controllers/org/example/SampleViewModel.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonController;
import griffon.inject.MVCMember;
import griffon.metadata.ArtifactProviderFor;
import griffon.transform.Threading;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonController;

import javax.annotation.Nonnull;
import javax.inject.Inject;

@ArtifactProviderFor(GriffonController.class)
public class SampleViewModel extends AbstractGriffonController {
    private SampleView view;
    private StringProperty input;
    private StringProperty output;

    @Nonnull
    public final StringProperty inputProperty() {
        if (input == null) {
            input = new SimpleStringProperty(this, "input");
        }
        return input;
    }

    public void setInput(String input) {
        inputProperty().set(input);
    }

    public String getInput() {
        return input == null ? null : inputProperty().get();
    }

    @Nonnull
    public final StringProperty outputProperty() {
        if (output == null) {
            output = new SimpleStringProperty(this, "output");
        }
        return output;
    }

    public void setOutput(String output) {
        outputProperty().set(output);
    }

    public String getOutput() {
        return output == null ? null : outputProperty().get();
    }

    @Inject
    private SampleService sampleService;

    @MVCMember
    public void setView(@Nonnull SampleView view) {
        this.view = view;
    }

    @Threading(Threading.Policy.INSIDE_UITHREAD_ASYNC)
    public void sayHello() {
        String input = getInput();                                             <i class="conum" data-value="1"></i><b>(1)</b>
        String output = sampleService.sayHello(input);                         <i class="conum" data-value="2"></i><b>(2)</b>
        setOutput(output);                                                     <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Read input</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Transform data</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Set as output</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The configuration is shown next.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/conf/Config.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
import griffon.util.AbstractMapResourceBundle;

import javax.annotation.Nonnull;
import java.util.Map;

import static griffon.util.CollectionUtils.map;
import static java.util.Arrays.asList;

public class Config extends AbstractMapResourceBundle {
    @Override
    protected void initialize(@Nonnull Map&lt;String, Object&gt; entries) {
        map(entries)
            .e("application", map()
                .e("title", "sample")
                .e("startupGroups", asList("sample"))
                .e("autoShutdown", true)
            )
            .e("mvcGroups", map()
                .e("sample", map()
                    .e("view", "org.example.SampleView")
                    .e("viewModel", "org.example.SampleViewModel")
                )
            );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In truth we could have had a <strong>Model</strong> member too, just like in the other pattern implementations. However MVVM prefers the
 <strong>Model</strong> to wrap a domain object or provide direct access to the data layer. As that&#8217;s not the case for this trivial
application the <strong>Model</strong> disappears and the data properties are moved to the <strong>ViewModel</strong>. This also servers to showcase
that MVC configurations can have less members than the stereotypical three.</p>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_tutorial_5_2_5">2.5. PMVC</h3>
<div class="paragraph">
<p>Finally we meet the last pattern. We begin again with the <strong>View</strong>.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/views/org/example/SampleView.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonView;
import griffon.inject.MVCMember;
import griffon.metadata.ArtifactProviderFor;
import javafx.fxml.FXML;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import org.codehaus.griffon.runtime.javafx.artifact.AbstractJavaFXGriffonView;

import javax.annotation.Nonnull;
import java.util.Collections;

@ArtifactProviderFor(GriffonView.class)
public class SampleView extends AbstractJavaFXGriffonView {
    private SampleController controller;
    private SampleModel model;

    @FXML private TextField input;
    @FXML private Label output;

    @MVCMember
    public void setController(@Nonnull SampleController controller) {
        this.controller = controller;
    }

    @MVCMember
    public void setModel(@Nonnull SampleModel model) {
        this.model = model;
    }

    @Override
    public void initUI() {
        Stage stage = (Stage) getApplication()
            .createApplicationContainer(Collections.&lt;String, Object&gt;emptyMap());
        stage.setTitle(getApplication().getConfiguration().getAsString("application.title"));
        stage.setWidth(400);
        stage.setHeight(120);
        stage.setScene(init());
        getApplication().getWindowManager().attach("mainWindow", stage);
    }

    // build the UI
    private Scene init() {
        Scene scene = new Scene(new Group());
        scene.setFill(Color.WHITE);
        scene.getStylesheets().add("bootstrapfx.css");

        Node node = loadFromFXML();
        ((Group) scene.getRoot()).getChildren().addAll(node);
        model.inputProperty().bindBidirectional(input.textProperty());         <i class="conum" data-value="2"></i><b>(2)</b>
        model.outputProperty().bindBidirectional(output.textProperty());       <i class="conum" data-value="2"></i><b>(2)</b>
        connectActions(node, controller);                                      <i class="conum" data-value="1"></i><b>(1)</b>

        return scene;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Connects user events to <strong>Controller</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Binds <strong>Model</strong> and <strong>View</strong></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Opposed to the other implementations, this <strong>View</strong> makes direct use of the <strong>Binder</strong>, thus foregoing the need to expose
UI elements to other MVC members. In this way, the <strong>View</strong> is self contained and all of its links are properly established.</p>
</div>
<div class="paragraph">
<p>The <strong>Model</strong> goes back to being a simple data holder, but this time it contains properties for both <em>input</em> and <em>output</em>,
as those define all the required data points.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/models/org/example/SampleModel.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonModel;
import griffon.metadata.ArtifactProviderFor;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonModel;

import javax.annotation.Nonnull;

@ArtifactProviderFor(GriffonModel.class)
public class SampleModel extends AbstractGriffonModel {
    private StringProperty input;
    private StringProperty output;

    @Nonnull
    public final StringProperty inputProperty() {
        if (input == null) {
            input = new SimpleStringProperty(this, "input");
        }
        return input;
    }

    public void setInput(String input) {
        inputProperty().set(input);
    }

    public String getInput() {
        return input == null ? null : inputProperty().get();
    }

    @Nonnull
    public final StringProperty outputProperty() {
        if (output == null) {
            output = new SimpleStringProperty(this, "output");
        }
        return output;
    }

    public void setOutput(String output) {
        outputProperty().set(output);
    }

    public String getOutput() {
        return output == null ? null : outputProperty().get();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last member we must discuss is the <strong>Controller</strong> itself.</p>
</div>
<div class="listingblock">
<div class="title">griffon-app/controllers/org/example/SampleController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java"> * limitations under the License.
 */
package org.example;

import griffon.core.artifact.GriffonController;
import griffon.inject.MVCMember;
import griffon.metadata.ArtifactProviderFor;
import griffon.transform.Threading;
import org.codehaus.griffon.runtime.core.artifact.AbstractGriffonController;

import javax.annotation.Nonnull;
import javax.inject.Inject;

@ArtifactProviderFor(GriffonController.class)
public class SampleController extends AbstractGriffonController {
    private SampleModel model;

    @Inject
    private SampleService sampleService;

    @MVCMember
    public void setModel(@Nonnull SampleModel model) {
        this.model = model;
    }

    @Threading(Threading.Policy.INSIDE_UITHREAD_ASYNC)
    public void sayHello() {
        String input = model.getInput();                                       <i class="conum" data-value="1"></i><b>(1)</b>
        String output = sampleService.sayHello(input);                         <i class="conum" data-value="2"></i><b>(2)</b>
        model.setOutput(output);                                               <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Read input</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Transform data</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Set as output</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This <strong>Controller</strong> has no need for a particular <strong>View</strong>, it only needs a <strong>PresentationModel</strong> that delivers the required
inputs and outputs. This greatly simplifies testing such components.</p>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_5_3">3. Conclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As you can see, Griffon is flexible enough and can adapt itself to your preferred MVC pattern. There are other MVC variants,
such as the <a href="https://en.wikipedia.org/wiki/Hierarchical_model%E2%80%93view%E2%80%93controller">Hierarchical model–view–controller</a>,
which is also automatically supported, given that Griffon enables hierarchical MVC groups and per-group contexts.</p>
</div>
<div class="paragraph">
<p>The preferred pattern is PMVC, as that&#8217;s the one suggested by the standatd Griffon archetypes.</p>
</div>
<div class="paragraph">
<p>The full code for these applications can be found
link:https://github.com/griffon/griffon/tree/ development_2_x/tutorials/patterns[here, window="_blank"].</p>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="#_tutorial_5_toc"><i class="fa fa-arrow-up"></i></a></span> <a href="#_tutorial_5_toc">Top</a></p>
</div>
</div>
</div></p>

    <hr />

        </div>
        <div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2008 - 2021 The Griffon Team | Mixed with <a href="https://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="https://jbake.org">JBake v2.6.5</a></p>
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>

  </body>
</html>
